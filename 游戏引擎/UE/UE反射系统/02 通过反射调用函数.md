---
create: '2025-03-09'
modified: '2025-03-09'
---

# 通过反射调用函数

通过反射调用注册的类成员函数，入口是`ProcessEvent`。

它是`UObject`的成员函数，也就是说，这个类应该继承自`UObject`才能做到反射调用。

## quick start

下面是一个遍历函数，找到对应函数名并进行调用的案例：

```C++
// example
for(TFieldIterator<UFunction> it(GetClass()); it; ++it)
{
    UFunction* FuncIns = *it;
    if(FuncIns->GetName().Equals(TEXT("myfunc")))
    {
        struct RefObject_eventFunc_Parms	// 构造 param_and_ret 的结构体
        {
            int32 ival;
            bool ReturnValue;
        }func_params;
        func_params.ival = 111;
        this->ProcessEvent(FuncIns,&func_params);	// 通过成员函数所在的实例指针去调用，在这里是this
        UE_LOG(LogTemp,Log,TEXT("call func return: %s"),func_params.ReturnValue?TEXT("true"):TEXT("false"));
    }
    UE_LOG(LogTemp,Log,TEXT("Function Name: %s"),*FuncIns->GetName());
}

// 封装成函数
template <typename RefObject_eventFunc_Parms>
void call_by_name(UObject* obj, const char* name, RefObject_eventFunc_Parms* func_params) {
    for(TFieldIterator<UFunction> it(GetClass());it;++it)
    {
        UFunction* FuncIns = *it;
        if(FuncIns->GetName().Equals(name))
        {
            obj->ProcessEvent(FuncIns, func_params);
        }
    }
}
```

## 原理

下面是整个过程的原理：`obj->ProcessEvent(f, params_and_ret)` => `UFunction.Invoke(this, param, ret)` => `execXXX(this, param, ret)` => `ret = XXX(param)`

## ProcessEvent

在`UObject`中，存在一个`ProcessEvent`函数，用于调用一个被反射的函数对象（`UFunction`），`Parms`用于传递参数和获取返回值。它的内部通过`UFunction`存储的函数指针，转移到UHT的exec函数，最终转发到真正的`Native C++`函数进行调用。

```C++
class UObject : public UObjectBaseUtility {
    ...
	/** Called by VM to execute a UFunction with a filled in UStruct of parameters */
	COREUOBJECT_API virtual void ProcessEvent( UFunction* Function, void* Parms );
    ...
}

// ProcessEvent 定义
void UObject::ProcessEvent( UFunction* Function, void* Parms )
{
    ...
    // 通过UFunction的Invoke转发到execXXX调用，返回值通过void* ReturnValueAddress返回到Parms里
    Function->Invoke(this, NewStack, ReturnValueAddress);
    
    ...
}
```

## UFunction Invoke()

`UFunction`的`Invoke`成员函数，用于调用`UFunction`内部的`execXXX`函数（见UHT Thunk函数部分）。

```C++
class UFunction : public UStruct
{
private:
	/** C++ function this is bound to */
	FNativeFuncPtr Func;
    
    ...
        
public:
    /**
	 * Invokes the UFunction on a UObject.
	 *
	 * @param Obj    - The object to invoke the function on.
	 * @param Stack  - The parameter stack for the function call.
	 * @param Result - The result of the function.
	 */
	COREUOBJECT_API void Invoke(UObject* Obj, FFrame& Stack, RESULT_DECL);
};

// Invoke 定义
void UFunction::Invoke(UObject* Obj, FFrame& Stack, RESULT_DECL)
{
	checkSlow(Func);

	UClass* OuterClass = (UClass*)GetOuter();
	if (OuterClass->IsChildOf(UInterface::StaticClass()))
	{
		Obj = (UObject*)Obj->GetInterfaceAddress(OuterClass);
	}

	TGuardValue<UFunction*> NativeFuncGuard(Stack.CurrentNativeFunction, this);
	return (*Func)(Obj, Stack, RESULT_PARAM);
}
```

## UHT生成的Thunk函数

UE 中成员函数实现反射和数据成员不同。它并没有依赖 C++ 的指向成员函数的指针，而是依赖 UHT 生成了一个统一原型的 Thunk 函数，在 Thunk 函数中调用真正执行的函数。

UHT会为反射的函数生成用于传递给 `ProcessEvent` 函数的参数结构，以及每个参数、返回值生成属性的反射信息（它们的内存偏移都是相对于 UHT 生成的参数结构的）。

### 实例myfunc的Thunk函数

如以下函数：

```C++
UFUNCTION()
bool myfunc(int32 InIval)
{
    UE_LOG(LogTemp,Log,TEXT("Function func: %d"),InIval);
    return true;
}
```

#### gen.cpp

##### execXXX定义

UHT会在gen.cpp中为execXXX函数生成对应的实现（gen.h中生成声明），并在其中执行真正的函数调用行为（或者执行蓝图字节码）：

```C++
// This macro is used to define a thunk function in autogenerated boilerplate code
#define DEFINE_FUNCTION(func) void func( UObject* Context, FFrame& Stack, RESULT_DECL )

DEFINE_FUNCTION(AMyActor::execmyfunc)
{
    P_GET_PROPERTY(FIntProperty,Z_Param_InIval);
    P_FINISH;
    P_NATIVE_BEGIN;
    *(bool*)Z_Param__Result=P_THIS->myfunc(Z_Param_InIval);
    P_NATIVE_END;
}
```

* 参数和返回值：

    * `Z_Param_InXXX`：函数参数，`Z_Param_In`+参数名。
    * `Z_Param__Result`：函数返回值，即传入的最后一个参数`RESULT_DECL`，它是一个void*

* 宏：

    * `P_GET_PROPERTY`：从Stack中获取传入的参数值到`Z_Param_InXXX`里（如果没有传参则设置为该类型的默认值）

    * `P_FINISH`：函数调用是通过一个虚拟机（VM）机制实现的，`Stack.Code` 是一个指针，指向当前执行的指令。当一个函数执行完毕后，需要将 `Stack.Code` 指向下一个指令（通常是返回指令或调用链中的下一个函数）。`P_FINISH` 的作用是确保在函数执行完成后，`Stack.Code` 正确地移动到下一个指令位置。

        ```C++
        #define P_FINISH	Stack.Code += !!Stack.Code; /* increment the code ptr unless it is null */
        ```

    * `P_THIS`：将`UObject* Context`转为所在this的类型（此处是`AMyActor*`）。

##### 将`execXXX`注册进UClass中

UHT还会在gen.cpp中生成将`myfunc`字符串和`execmyfunc`函数绑定注册到`UClass`中，同时为这些函数创建`UFunction`对象：

```C++
void AMyActor::StaticRegisterNativesAMyActor()
{
    UClass* Class = AMyActor::StaticClass();
    static const FNameNativePtrPair Funcs[] = {
        { "myfunc", &AMyActor::execmyfunc },
    };
    FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));
}
```

## 总结

UFunction的反射调用，总结来说：

* 注册：是UHT先创建了一个`exec`的统一函数签名，将其注册到`UClass`的`UFunction`中。
* 调用：在`ProcessEvent`中调用`UFunction`的`exec`函数指针，最终调用到`func`里。

## 参考资料

* [UE 反射实现分析：基础概念 | 虚幻社区知识库](https://ue5wiki.com/wiki/12624/)
* [UE 反射实现分析：C++ 特性 | 虚幻社区知识库](https://ue5wiki.com/wiki/23694/)