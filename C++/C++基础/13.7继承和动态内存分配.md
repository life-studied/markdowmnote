## 继承和动态内存分配

> 在基类使用动态分配内存new时，派生类情况

---

#### 1.派生类不使用new

> 派生类中没有需要new的数据成员，无需显式定义析构函数，复制构造函数和赋值运算符。

**析构函数**

> 编译器会使用一个默认析构函数，不执行任何操作，再自动调用基类的析构函数。适合。
>
> 注：与复制和赋值不同，在显式定义中也会自动调用基类的析构函数

**复制构造函数**

> 派生类的默认复制构造函数会自动调用基类的复制构造函数，再将派生类多余的数据成员复制，因此适合。
>
> 如果显式定义，则**不会**自动调用基类的复制构造函数，需要显式调用，一般放在初始化列表中调用。
>
> 如果存在成员是一个类的情况，例如string，也会自动调用其对应的函数。

**赋值运算符函数**

> 与复制构造函数一致，在默认赋值运算符中会自动调用基类的赋值运算符函数，因此也适合。



#### 2.派生类使用new

> 必须为派生类定义显式的析构函数，复制构造函数和赋值运算符。

**析构函数**

> 派生类析构函数不论定不定义，都自动调用基类的析构函数。所以在定义时只需对派生类中组件进行释放空间即可。

**复制构造函数**

> 使用成员初始化列表中调用基类的复制构造函数，来将待复制的派生类中的基类部分复制，再在函数定义中处理其余派生类成员的初始化。
>
> 注：初始化列表中不能直接初始化基类成员，这是不允许的！！只能通过基类的复制构造函数来初始化。

**赋值构造函数**

> 在派生类赋值构造函数中显式调用基类赋值构造函数，再对派生类中剩余变量进行赋值。开头需要判断赋值对象是否为自己。
>
> 注：调用基类赋值构造函数必须使用函数表示法来使用作用域解析运算符，否则将变为调用自己形成递归。

