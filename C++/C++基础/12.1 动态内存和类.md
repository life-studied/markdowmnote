---
create: 2023-07-08
---
## 12.1 动态内存和类

#### 12.1.1静态类成员

特点：无论创建了多少对象，程序都只创建了一个静态类副本，即所有成员共享一个静态成员

> 注：这个特性用于统计同类对象总数目很有用

**案例**

```c++
class stringBad{
    char *str;
    int len;
    static int num_strings;		//静态类成员
public:
    StringBad();
    ...
}
```

**初始化静态类成员**

> 因为类声明并不分配空间，所以初始化可以放在方法文件中作为全局变量初始化
>
> 另外不在类文件中初始化的原因是，头文件被包含在多个文件，如果在头文件中进行初始化，可能出现多个初始化副本而报错

#### 12.1.2特殊成员函数

> c++自动隐式的提供了下面这些成员函数：
>
> 默认构造函数
>
> 默认析构函数
>
> 复制构造函数
>
> 赋值运算符
>
> 地址运算符

---

##### 复制构造函数

> 函数原型：Class_name(const Class_name &)

**1.何时调用**

> 新建一个对象并将其初始化为同类现有对象时。注意：这在**一条**语句中。

> 注意：这既表现在正常新建变量时，也表现在按值传参中。

**2.功能**

> 逐个复制非静态成员的值，如果成员是类，则调用这个类的复制构造函数。不处理静态成员，因为它属于整个类。

**注：复制构造函数不调用构造函数中的语句，但是会在对象消失时调用析构函数，所以可能会出现两者某些约定（空间、静态类）失败的错误**

**3.创建显式复制构造函数**

> 为了解决上述问题，可以手动创建显式复制构造函数来替代默认构造函数

**案例**

```c++
StringBad::Stringbad(const String & s)	//使用引用
{
    num_strings++;		//约定的静态成员数目增加
    len=st.len;
    str=new char[len+1];
    std::strcpy(str,st.str);//将字符串复制一个副本，而不是地址，避免引发两者指向同一个字符串的问题
    ...
}
```

---

##### 赋值运算符

>函数原型：Class_name & Class_name::operater=(const Class_name &);

**注意：使用引用作为返回值是为了能够实现连等的操作**

> 初始化对象时，不一定会使用赋值运算符，但一定会使用复制构造函数。
>
> 区别在于一步解决初始化，还是两步解决

---

对于赋值问题与复制构造函数的区别（主语：赋值函数）

**1.目标对象可能引用了以前分配的数据，应使用delete来删除**

**2.应考虑到将对象赋值给自身带来的删除原有数据的问题**

**3.返回一个指向调用对象的引用**











