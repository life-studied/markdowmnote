## 8.2 引用变量

> 定义：引用是已定义变量的别名。

> 用处：
>
> 1.用作函数的参数，来使函数更改原始数据
>
> 2.设计类

#### 8.2.1创建引用变量

> c++使用&符号来声明引用

例如：

```c++
int rat;
int & mouse = rat;
//rat和mouse指向相同的值和内存单元
```

注意：此处&不是地址运算符，而是类型标志符一部分，类似于*。int &指的是指向int的引用

#### 引用与指针的区别

引用本质上是指针，但是规定更加严格。

首先，引用必须一声明就初始化

其次，引用不允许更改其对应的变量

综上，引用应当这样理解：

```c++
int & mouse = rat;
//类似于
int * const pr = &rat;
```

###### 警告：引用在再次赋值时不会给出警告，因为其默认为将其所代表的变量更改值，而不是将这个引用换一个代表的变量。因为引用只允许在初始化时设置别名。

#### 8.2.2将引用作为函数参数

```c++
#include<iostream>
void swap(int & a,int & b);

int main()
{
    int c=5,d=10;
    swap(c,d);
    return 0;
}

void swap(int &a,int &b)
{
    int temp;
    temp=a;
    a=b;
    b=temp;
}
```

#### 8.2.3引用属性的特殊之处

如果既想要按引用传递参数的便利性，又不想原变量在不知不觉中被改变，可以这样使用

```c++
double refcube(const double &ra);
//这意味着不能通过引用改变变量的值,同时能不用指针来简化操作
```

另一方面，一些值不能用引用传递，例如：

```c++
refcube(x+20);
```

如果这样做了，将会创建一个匿名的临时变量来作为引用的原变量（这是在有const限定时才可能），并先将该变量初始化为传入的值

##### 创建临时变量的情况

###### 1.实参类型正确，但不是左值

###### 2.实参类型不正确，但可以转换为正确的类型

#### 8.2.4将引用用于结构

> 此处有一点值得注意
>
> 针对引用，我们可以将这类返回值作为左值

```c++
accumulate(dup,five)=four;
//free_throw & accumulate(free_throw & target,free_throw & source);
```

如果禁止这种用法，可以在返回值上加上限制const

```c++
const free_throw & accumulate(free_throw & target,free_throw & source);
```

#### 8.2.5将引用用于类对象

#### 8.2.6对象、继承和引用

继承的特征：

派生类能继承基类的方法

基类引用能指向派生类对象，无需强制转换

#### 8.2.7何时使用引用参数

主要原因：

1.能修改函数参数所指向的数据对象

2.提高速度



指针与引用，选用哪个

1.数据对象很小，都可传递

2.数组必须用指针

3.较大的结构，都可

4.类对象，引用









