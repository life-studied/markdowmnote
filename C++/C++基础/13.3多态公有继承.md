## 多态公有继承

> **多态：**同一个方法在基类和派生类中的实现不同

实现机制：

1.在派生类中重新定义基类的方法

2.使用虚方法

#### 13.3.1虚方法

> 在基类和派生类中定义两个同名的方法，则将会根据对象类型来确定使用哪一个版本。但是如果是指针或引用调用了方法，则可能出现派生类调用基类的方法的情况，因为调用只根据指针或引用类型。
>
> 这时就需要虚方法来解决。虚方法保证调用根据指向对象的类型，而不是指针或引用类型。

**语法**

> 声明时在函数前加virtual，定义时基类和派生类都需要定义这个同名函数（实现不同）

例：

```c++
class test			//基类
{
    ...
    virtual void ViewAct();
    ...
}

class testadd ： public test		//派生类
{
    virtual void ViewAct();
}

//实现
test::void ViewAct()		//基类
{
    ...
}

testadd::void ViewAct()		//派生类
{
    ...
}
```

注：派生类的虚函数实现可能会用到基类的虚函数来提高代码复用性，使用时要加上：：来防止使用错误导致无效递归。

**应用场景**

> 如果需要使用数组来管理大量基类和派生类，由于数组本身需要元素类型一致，所以可以使用基类类型的指针数组，使其既能指向基类，又能指向派生类。



##### 虚析构函数

> 派生类和基类的构造函数不会因为指针而使用错误。但析构函数会，因此需要虚析构函数。