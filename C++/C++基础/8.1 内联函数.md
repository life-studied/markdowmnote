## 8.1 内联函数

> 内联函数使用相应的函数代码代替函数调用，来减少进行函数调用的前置步骤需要的时间，使程序无需跳到另一个位置去执行代码。代价是占用更多内存。

#### 选用内联函数的情况

> 如果函数代码本身执行很简单，且调用次数很少，那可以选择内联函数。
>
> 如果函数代码执行所需的时间比处理函数调用机制时间长，或是多次调用，则应该使用函数调用。

#### 使用内联函数的措施

**1.在函数声明前加关键词“inline”**

**2.在函数定义前加关键词“inline”**

注：常用做法是直接在函数原型处写函数定义即函数头和所有函数代码（函数定义省略）

#### 注意事项

内联函数不支持递归（从内联函数的定义很明显可以看出来）

#### 示例

```c++
#include<iostream>
inline double square(double x)
{
    return x*y;
}

int main()
{
    using namespace std;
    double a,b;
    double c=13.0;
    a=square(5.0);
    b=square(4.5+7.5);
    cout<<"a="<<a<<",b="<<b<<endl;
    cout<<"c="<<c;
    cout<<",c square ="<<square(c++)<<"\n";
    cout<<"Now c ="<<c<<"\n";
    return 0;
}
```



### 补充内容

#### 内联与宏

宏定义虽然部分能代替内联函数，但是很多情况下会有问题：宏定义不能按值传递

例如，如果将上述函数使用宏定义

```c++
#define SQUARE(X) ((X)*(X))
//注：此处特意加上（）来防止宏定义的某些问题
```

调用函数SQUARE(C++)将会把C递增两次，而原来的函数将C递增一次的值传入函数

