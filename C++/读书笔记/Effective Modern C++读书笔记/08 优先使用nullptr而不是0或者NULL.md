# 08 优先使用nullptr而不是0或者NULL

​	 **0 和 NULL 都不属于指针类型**。 在 C++98 中，这意味着传递 0 或者 NULL 作为参数给重载函数永远不会调用指针重载的那个函数：

```C++
void f(int); // 函数f的三个重载
void f(bool);
void f(void*);

f(0); 		// 调用 f(int)，而非f(void*)
f(NULL); 	// 可能无法编译，但是调用f(int)
			// 不可能调用 f(void*)
```

​	如果 `NULL` 被定为 `0L` （即 `0` 作为一个 `long` 整形），函数的调用是有歧义的，因为 `long` 转化为 `int` ， `long` 转化为 `bool` ， 0L 转换为 `void*` 都被认为是同样可行的。

​	注意：使用NULL进行函数调用，在**源代码的语义和它的实际情况存在着冲突**。这种违背直觉的行为正是 C++98 程序员不被允许重载指针和整数类型的原因。

---

​	`nullptr` 的优势是它不再是一个整数类型。诚实的讲，它也不是一个指针类型，但是你可以把它想象成一个可以指向任意类型的指针。 `nullptr` 的类型实际上是 `std::nullptr_t` ， `std::nullptr_t` 定义为 `nullptr` 的类型，这是一个完美的循环定义。 

​	`std::nullptr_t` 可以隐式的转换为所有的原始的指针类型，这使得 `nullptr` 表现的像可 以指向任意类型的指针。

