---
create: 2023-07-08
---
## 调试core文件

> 当程序挂掉，会产生一个core dump的错误，并生成一个core文件

#### 1.查看core文件情况

```shell
$ ulimit -a	

core file size          (blocks, -c) 0		#core文件默认不生成
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7469
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7469
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

#### 2.修改为无限制（unlimited）

```shell
ulimit -c unlimited
```

#### 3.案例

##### 3.1 挂掉的程序

```c
//test.c
#include<stdio.h>
void bbb(int b)
{
        int * c = 0;
        *c = 100;
}

void aaa(int a)
{
        bbb(a);
}

int main()
{
        aaa(100);
        return 0;
}

```

##### 3.2 运行

```shell
gcc test.c -o test
./test
```

> 此时产生了一个core文件（core.xxxx）

##### 3.3 使用gdb调试core文件

```shell
$ gdb test core-test-3218-1677370941

#显示错误
Reading symbols from test...
[New LWP 3218]
Core was generated by `./test'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000400549 in bbb (b=100) at t.c:5
5		*c = 100;
```

##### 3.4 查看函数调用栈

```shell
(gdb) bt
#0  0x0000000000400549 in bbb (b=100) at t.c:5
#1  0x0000000000400567 in aaa (a=100) at t.c:10
#2  0x0000000000400578 in main () at t.c:15
```



#### 4.其它：core文件不产生的问题

##### 4.1 ulimit问题

```shell
ulimit -a	#查看
ulimit -c unlimited	#更改
```

##### 4.2 保存位置问题

```shell
cat /proc/sys/kernel/core_pattern	#查看保存位置
echo  "core-%e-%p-%t" > /proc/sys/kernel/core_pattern	#更改保存位置

		#vim /etc/sysctl.conf
		#添加一行：kernel.core_pattern=core-%e-%p-%t
echo "kernel.core_pattern=core-%e-%p-%t" >> /etc/sysctl.conf	#使永久生效

sysctl -p 	#让配置立刻生效
```

