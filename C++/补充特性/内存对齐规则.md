---
create: 2023-07-08
modified: '2025-03-21'
---

# 内存对齐规则

#### 1.规则：

* **数据成员**：每个数据成员的起始地址必须是其自身大小或对齐系数（如通过`#pragma pack`指定的值）中较小者的整数倍
* **结构体总大小**：结构体的总大小必须是其内部最大成员大小或对齐系数中较小者的整数倍

#### 2.规则说明：

1. 为什么数据成员的起始地址是自身大小的整数倍？
    * **内存总线和缓存行**：内存总线和缓存行的设计通常是以固定大小的块为单位进行操作的。例如，即使在64位系统中，缓存行大小可能是64字节。如果数据未对齐，可能会跨越多个缓存行，导致缓存未命中率增加。
    * **指令集和硬件优化**：处理器有专门的指令（**`MOVZX`或`MOVSX`指令**）用于读取不同大小的数据类型（如1字节、2字节、4字节等），这些指令的设计通常假设数据是按其大小对齐的。
2. 结构体的总大小必须是其内部最大成员大小或对齐系数中较小者的整数倍
    * **保证结构体数组的对齐**：结构体数组是常见的数据结构，其中每个结构体元素的起始地址需要满足最大成员的对齐要求。如果结构体的大小不是最大成员大小的倍数，那么在数组中，除了第一个元素外，其他元素的最大成员将无法满足对齐要求，从而影响访问效率。

#### 案例

请看下面的代码：

```c++
// 例1：默认对齐方式
struct A {
    char a; // 占1字节，偏移0
    int b; // 占4字节，偏移4（因为要对齐到4的倍数）
    char c; // 占1字节，偏移8
}; // 结构体A的大小为12（因为要对齐到最大成员的倍数）

// 例2：使用#pragma pack(2)指令
#pragma pack(2) // 设置对齐字节数为2
struct B {
    char a; // 占1字节，偏移0
    int b; // 占4字节，偏移2（因为要对齐到2的倍数）
    char c; // 占1字节，偏移6
}; // 结构体B的大小为8（因为要对齐到指定的倍数）
#pragma pack() // 恢复默认对齐方式

// 例3：使用__attribute__((aligned(8)))指令
struct C {
    char a; // 占1字节，偏移0
    int b __attribute__((aligned(8))); // 占4字节，偏移8（因为要对齐到8的倍数）
    char c; // 占1字节，偏移12
}; // 结构体C的大小为16（因为要对齐到最大成员的倍数）

// 例4：使用C++11中的alignas关键字
struct D {
    alignas(16) char a; // 占1字节，偏移0（但是占用16个空间）
    int b; // 占4字节，偏移16（因为要对齐到16的倍数）
    char c; // 占1字节，偏移20
}; // 结构体D的大小为32（因为要对齐到最大成员的倍数）

// 例5：含double的结构体
struct E {
    int a;
    double b;
    char c;
}; // 结构体E的大小为24
```