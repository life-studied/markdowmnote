---
create: '2025-01-07'
modified: '2025-01-07'
---

# MT 和 MD 详解

## 1. MT 和 MD 的区别是什么

`/MT` 和 `/MD` 是 Visual C++ 编译器的两种运行时库链接方式，它们的主要区别如下：

| 特性             | `/MD`（动态链接）                                            | `/MT`（静态链接）                  |
| ---------------- | ------------------------------------------------------------ | ---------------------------------- |
| **运行时库**     | 依赖外部的运行时库 DLL（如 `VCRUNTIME140.dll`、`ucrtbase.dll`等） | 将运行时库代码嵌入到 EXE 文件中    |
| **EXE 文件大小** | 较小                                                         | 较大                               |
| **运行时依赖**   | 需要安装 Visual C++ Redistributable（即依赖上述dll，拷贝也行） | 无需额外依赖                       |
| **适用场景**     | 大型应用程序、插件、共享库                                   | 独立工具、嵌入式系统、小型应用程序 |

>**常见的运行时库 DLL**
>
>- **C 运行时库**：
>  - `ucrtbase.dll`：通用 C 运行时库（Universal C Runtime）。
>  - `msvcrt.dll`：旧版 C 运行时库（已过时，不推荐使用）。
>- **C++ 运行时库**：
>  - `VCRUNTIME140.dll`：C++ 运行时支持（如异常处理、内存管理）。
>  - `MSVCP140.dll`：C++ 标准库支持（如 `std::vector`、`std::string`）。
>- **其他 DLL**：
>  - `api-ms-win-*.dll`：Windows API 的转发 DLL。
>  - `kernel32.dll`、`user32.dll` 等：Windows 系统库。

## 2. MT 和 MD 的选择

选择 `/MT` 还是 `/MD` 取决于具体的应用场景和需求。以下是选择时的考虑因素：

### 1. **静态库（.lib）的情况**
   - **必须统一运行时库类型**：
     - 如果主程序使用 `/MD`，所有静态库也必须使用 `/MD`。
     - 如果主程序使用 `/MT`，所有静态库也必须使用 `/MT`。
   - **原因**：静态库的代码会被直接链接到主程序中，运行时库状态必须一致，否则会导致内存管理、异常处理等问题。

### 2. **动态库（.dll）的情况**
   - **可以各自选择运行时库类型**：
     - 动态库（`.dll`）是一个独立的模块，它有自己的运行时库状态。
     - 因此，动态库和主程序可以使用不同的运行时库类型（例如主程序使用 `/MD`，动态库使用 `/MT`）。
   - **注意事项**：
     - 如果动态库和主程序之间传递了与运行时库相关的对象（如**内存指针、STL 容器、异常**等），则必须使用相同的运行时库类型。
     - 如果动态库和主程序之间只通过简单的接口（如基本类型参数）交互，则可以混合使用 `/MD` 和 `/MT`。

## 3. 主模块与 DLL 使用MT的问题（在MT情况下）

在MT情况下，每个模块都有自己的运行时库，而每个运行时库有自己的内存管理器。因此必须保证DLL 申请的内存应由 DLL 释放，主模块申请的内存由主模块释放。

### 1. **内存分配和释放的一致性**
**DLL 申请的内存应由 DLL 释放**：

如果 DLL 使用 `/MT`，它会有自己的内存管理器。每个运行时库（如 `VCRUNTIME140.dll` 或静态链接的运行时库）都有自己的堆（heap）管理机制。在一个堆中分配的内存，不能在另一个堆中释放。

### 2. **如何确保内存管理的一致性**
   - **DLL 提供分配和释放接口**：
     - DLL 应提供配套的内存分配和释放函数，供主程序调用。例如：
     
       ```cpp
       // MyDLL.cpp
       #include <iostream>
       #include <cstdlib>
       
       extern "C" __declspec(dllexport) void* AllocateMemory(size_t size) {
           return malloc(size);  // 使用 DLL 的内存管理器分配内存
       }
       
       extern "C" __declspec(dllexport) void FreeMemory(void* ptr) {
           free(ptr);  // 使用 DLL 的内存管理器释放内存
       }
       ```
   - **主程序遵循 DLL 的规则**：
     - 主程序必须调用 DLL 提供的释放函数来释放内存，而不是直接使用 `delete` 或 `free`。

### 3. **其他注意事项**
   - **STL 对象**：
     - 避免在 DLL 和主程序之间传递 STL 对象（如 `std::string`、`std::vector`），因为它们的实现可能依赖于运行时库。
   - **异常**：
     - 避免在 DLL 和主程序之间传递异常，因为异常处理机制也依赖于运行时库。
   - **文件句柄和其他资源**：
     - 类似于内存，文件句柄、线程句柄等资源也应由分配它们的模块释放。

## 4. 主模块与 DLL 使用MD的问题

如果 **DLL 和可执行文件都使用了 `/MD`**，并且链接的是 **同一个运行时库 DLL**（例如 `VCRUNTIME140.dll`），那么通常情况下 **不需要特别关注内存问题**，因为它们共享同一个运行时库和内存管理器。

然而，仍然有一些细节需要注意：

| **类别**     | **注意事项**                                                 | **解决方案**                                                 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **STL 对象** | - 避免跨模块传递 STL 对象（如 `std::string`、`std::vector`）。 | - 使用简单的数据类型（如 `char*`、`int` 等）或自定义数据结构跨模块传递数据。 |
|              | - 不同编译器版本或设置可能导致 STL 实现不一致。              | - 如果必须传递 STL 对象，确保 DLL 和可执行文件使用相同的编译器版本和设置。 |
| **异常处理** | - 避免跨模块抛出和捕获异常。                                 | - 在 DLL 内部捕获异常，并将错误信息通过返回值或回调函数传递给可执行文件。 |
| **资源管理** | - 类似于内存，其他资源（如文件句柄、线程句柄等）也应由分配它们的模块释放。 | - 如果 DLL 打开了一个文件句柄，应该由 DLL 关闭该句柄，而不是由可执行文件关闭。 |