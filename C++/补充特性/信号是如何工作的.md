---
create: '2025-07-16'
modified: '2025-07-16'
---

# 信号是如何工作的

## 信号简介

信号（Signal）是Linux/Unix系统中用于进程间通信（IPC）的一种异步通知机制，由内核或进程发送，用于通知目标进程发生了某种事件。信号是**软件中断**，可类比硬件中断，但由内核通过软件触发。

信号的来源：

- **硬件异常**：如除零错误（`SIGFPE`）、非法内存访问（`SIGSEGV`）。
- **用户输入**：如终端按下`Ctrl+C`（`SIGINT`）、`Ctrl+Z`（`SIGTSTP`）。
- **进程操作**：如`kill`命令（`SIGTERM`、`SIGKILL`）、`kill()`系统调用。
- **内核事件**：如子进程退出时父进程收到`SIGCHLD`。

## 信号的生命周期

信号的生命周期，本质上就是信号由某个进程或内核产生了，然后发往某个进程或线程的挂起队列里，在进程从内核态回到用户态的时候（正常回归或者由于信号被迫返回），去检查并处理信号。

### 信号的产生和传递

内核里每个进程（确切地说是每个 task_struct）都维护着一个**挂起信号队列**（`struct sigpending`）。

当有人（另一个进程或内核自己）调用 `kill(pid, signo)` / `tgkill()` / `raise()` / 按下 Ctrl-C 等，内核根据给定的 pid/tid 把这封信——信号结构体（`sigqueue` 对象）——挂到目标进程或线程的挂起队列里。

- 如果信号是发给进程（pid>0），就挂在进程级队列；
- 如果是发给特定线程（tgkill），就挂在线程级队列。

同时，内核把进程/线程的挂起信号位图（`task_struct->pending.signal`）里对应 signo 的那一位设为 1，表示“信箱里有这封信”。

如果进程当前因为 `sigprocmask()`/`pthread_sigmask()` 把该信号**阻塞**了，这封信就留在队列里“等待”；否则立即进入下一步“递交”。

### 信号处理的发生（重点）

信号的处理虽然说是任何时刻都可能发生，但具体而言进程不会无缘无故地跳转到信号的处理流程，而是发生在以下几种时刻：

1. 进程唤醒
   - 可中断睡眠：若目标进程正处于比如 `read()`/`select()`/`sleep()`这些可中断睡眠——内核会把它唤醒，状态改为 TASK_RUNNING，让它有机会去处理信号。
   - 不可中断睡眠：若进程在不可中断睡眠（如NFS 失联、块层死锁等），会把进程挂进 `D` 状态，则信号暂时不会唤醒。
2. 调度点检查
   - 每次从内核态返回用户态（系统调用返回、中断返回、调度器挑选到该进程）时，内核都会检查“**我有可递交的未决信号吗**”？如果 signo 未被阻塞，就进入真正的递交流程。

### 信号正式的处理流程

内核根据进程对该信号的设置，走三条路之一：

* **忽略**（`SIG_IGN`）——直接丢弃。
* **默认动作**——执行内核预设动作：终止、终止+core、停止、继续等。
* **用户处理函数**（`sa_handler`/`sa_sigaction`）——内核做以下动作：
  1. 保存用户态的现场：保存当前用户态寄存器现场到信号帧（sigframe）压入用户栈；
  2. 把 PC 设成用户注册的 handler；
  3. CPU 回到用户态，执行 handler。
  4. 内核再从栈上恢复现场，进程继续从被中断处往下跑。
  5. 在恢复现场的过程中，内核再次检查是否还有未决信号，有就重复上述步骤。

## 信号永远无法处理的情况

这是一个很有趣的问题，一般而言，信号很难出现永远不被处理，因为进程即使在阻塞进行io时，也是在等待io完成，此时可以立刻被唤醒然后处理信号。

但是信号依然可以不被处理：

* 进程主动阻塞信号：信号被阻塞（`sigprocmask`/`pthread_sigmask` 把对应位 mask 住）。
  此时信号只是“挂起”，一旦解除阻塞就会立即处理。但是这种阻塞不能屏蔽**SIGKILL（9）和 SIGSTOP（19）**。
* D状态且等待的进程：这种情况下进程无法被唤醒，因此无法对信号进行反应。但是管理员依然可以用 `kill -9`/`kill -19` 把你拉出来，因为内核硬编码会去强制检查 `SIGKILL/SIGSTOP`。

### 为什么可以永远等不到

设备掉线、光纤被拔、NFS 服务器永久性离线、内核模块 bug、块层死锁……这些极少见的，由于内核设计上的bug导致的D状态，才会让对应的 I/O 请求永远不被完成，进程就一直挂在等待队列里，内核不会把它唤醒。这些处于D状态的进程只能等待上述的问题被解决，或者重启整个操作系统。

### 主动进入信号处理并故意不退出（no）

很有意思的是，有时候会觉得如果进程主动进入信号处理，那么在这里面去做事情，不就可以防止其他信号抢占了吗？但是这样是不行的。

内核希望尽快让高优先级或紧急信号得到响应，因此如果信号的优先级不够高，线程就会立刻切换到后来的更高优先级的信号去执行处理函数，做完了再回去接着处理原来的信号。

因此在信号处理中不退出的做法，不能阻止更高优先级的信号（如kill -9）的到来。