---
create: '2024-12-14'
modified: '2024-12-14'
---

# coroutine函数（规定与返回值）

在C++20中，协程与普通的函数的一样的，都是以一种函数的形式展现；标准规定，如果一个函数的**返回类型符合协程的规则**的类型，那么这个函数就是一个协程。

## 协程的返回值类型

区别一个函数是不是协程，是通过它的返回值类型来判断的。如果它的返回值类型满足协程的规则，那这个函数就会**被编译成**协程。

> 规则如下：
>
> ```C++
> template <class _Ret, class = void>
> struct _Coroutine_traits {};
> 
> template <class _Ret>
> struct _Coroutine_traits<_Ret, void_t<typename _Ret::promise_type>> {
>     using promise_type = typename _Ret::promise_type;
> };
> 
> template <class _Ret, class...>
> struct coroutine_traits : _Coroutine_traits<_Ret> {};
> ```

简单来说，就是返回值类型 `_Ret` 能够找到一个类型 `_Ret::promise_type` 与之相匹配。这个 `promise_type` 既可以是直接定义在 `_Ret` 当中的类型，也可以通过 `using` 指向已经存在的其他外部类型。

此时，我们就可以给出 `Result` 的部分实现了：

```C++
struct Result {
  struct promise_type {
    ...
  };
};
```

## 协程的返回值从哪来

**协程函数并不直接创建返回值**。

```C++
Result Coroutine(int start_value) {
  std::cout << start_value << std::endl;
  co_await std::suspend_always{};
  std::cout << start_value + 1 << std::endl;
};
```

如上所示，协程的返回值并非函数中手动返回；而是需要在`promise_type`中额外处理：

通过`Result get_return_object()`函数，协程函数会在开始时自动调用它创建一个返回值对象。

```C++
struct Result {
  struct promise_type {

    Result get_return_object() {
      // 创建 Result 对象
      return {};
    }

    ...
  };
};
```

> 再次强调：不同于一般的函数，协程的返回值并不是在返回之前才创建，而是在协程的状态创建出来之后马上就创建的。也就是说，协程的状态被创建出来之后，会立即构造 `promise_type` 对象，进而调用 `get_return_object` 来创建返回值对象。

另外关于`promise_type`的**构造函数**：`promise_type` 类型的构造函数参数列表如果与协程的参数列表一致，那么构造 `promise_type` 时就会调用这个构造函数。否则，就通过默认无参构造函数来构造 `promise_type`。

​