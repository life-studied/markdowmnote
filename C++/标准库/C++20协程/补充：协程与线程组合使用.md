---
create: '2024-12-14'
modified: '2024-12-14'
---

# 协程与线程组合使用

```C++
#include <iostream>
#include <coroutine>
#include <future>
#include <chrono>
#include <thread>

struct Result {
	struct promise_type {
		std::suspend_never initial_suspend() {
			return {};
		}

		std::suspend_never final_suspend() noexcept {
			return {};
		}

		Result get_return_object() {
			return {};
		}

		void return_void() {

		}

		//    void return_value(int value) {
		//
		//    }

		void unhandled_exception() {

		}
	};
};

struct Awaiter {
	int value;

	bool await_ready() {
		return false;
	}

	void await_suspend(std::coroutine_handle<> coroutine_handle) {
		auto f = std::async(std::launch::async, [=]() {
			using namespace std::chrono_literals;
			std::this_thread::sleep_for(1s);
			std::cout << std::this_thread::get_id() << std::endl;
			coroutine_handle.resume();
			});
		std::cout << std::this_thread::get_id() << std::endl;
		coroutine_handle.resume();
	}

	int await_resume() {
		return value;
	}

	~Awaiter() { std::cout << "~Awaiter" << std::endl; }
};

Result Coroutine() {
	std::cout << std::this_thread::get_id() << std::endl;
	std::cout << 1 << std::endl;
	std::cout << co_await Awaiter{ .value = 1000 } << std::endl;
	std::cout << std::this_thread::get_id() << std::endl;
	std::cout << 2 << std::endl;
	std::cout << 3 << std::endl;
	co_await std::suspend_always{};
	std::cout << 4 << std::endl;

	co_return;
};

int main() {
	Coroutine();
	return 0;
}
```



```C++
#include <iostream>
#include <coroutine>
#include <future>
#include <chrono>
#include <thread>

struct Result {
	struct promise_type {
		std::suspend_never initial_suspend() {
			return {};
		}

		std::suspend_never final_suspend() noexcept {
			return {};
		}

		Result get_return_object() {
			return {};
		}

		void return_void() {

		}

		//    void return_value(int value) {
		//
		//    }

		void unhandled_exception() {

		}
	};
};

struct Awaiter {
	int value;

	bool await_ready() {
		return false;
	}

	void await_suspend(std::coroutine_handle<> coroutine_handle) {
		std::thread t([=]() {
			using namespace std::chrono_literals;
			std::this_thread::sleep_for(1s);
			std::cout << std::this_thread::get_id() << std::endl;
			coroutine_handle.resume();
			});
		t.detach();
		std::cout << std::this_thread::get_id() << std::endl;
		coroutine_handle.resume();
	}

	int await_resume() {
		return value;
	}

	~Awaiter() { std::cout << "~Awaiter" << std::endl; }
};

Result Coroutine() {
	std::cout << std::this_thread::get_id() << std::endl;
	std::cout << 1 << std::endl;
	std::cout << co_await Awaiter{ .value = 1000 } << std::endl;
	std::cout << std::this_thread::get_id() << std::endl;
	std::cout << 2 << std::endl;
	std::cout << 3 << std::endl;
	co_await std::suspend_always{};
	std::cout << 4 << std::endl;

	co_return;
};

int main() {
	Coroutine();
	return 0;
}
```