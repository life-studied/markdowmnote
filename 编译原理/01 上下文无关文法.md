---
create: '2025-05-24'
modified: '2025-05-24'
---

# 上下文无关文法

上下文无关文法由四个元素组成：

* 终结符号集合
* 非终结符号集合
* 产生式集合
* 开始符号（指定为某个非终结符号）

编程语言的设计，都可以使用上下文无关文法来描述，从一个开始符号开始，一步一步依据产生式集合中的规则进行分解，成为终结符合和非终结符号，最终变成一堆终结符号。

这种递归式设计，用少量的文字就能描述非常复杂的规则。

## 1. 终结符号集合（Terminal Symbols）

终结符号是文法中不能再被分解的基本符号。比如在C++中，`int`、`+`、`;`、变量名等都是终结符号。它们是语言的“原子”组成部分，就像英语中的单词一样。

为什么需要定义终结符号集合？

- **明确语言的基本单位**：终结符号是语言的最小单位，通过定义终结符号集合，我们可以明确语言中所有可能的“原子”成分。
- **方便语法分析**：在编译过程中，语法分析器会将输入的源代码（由终结符号组成）与文法规则进行匹配，终结符号集合为这个过程提供了基础。

## 2. 非终结符号集合（Non-terminal Symbols）

非终结符号是表示语言结构的符号，它们可以被进一步展开为更复杂的结构。比如在C++的语法规则中，`Expression`、`Statement`等都是非终结符号。

为什么需要定义非终结符号集合？

- **抽象语言结构**：非终结符号用于表示语言中的复杂结构，比如一个表达式、一个语句等。通过定义非终结符号，我们可以将复杂的语言结构分解为更小的单元，便于理解和分析。
- **递归定义**：很多语言结构是递归的，比如表达式可以包含子表达式。非终结符号允许我们用递归的方式定义这些结构。

## 3. **产生式集合（Production Rules）**

产生式是描述非终结符号如何展开为更简单结构的规则。比如：

```
Expression -> Expression + Term
Expression -> Term
Term -> Number
```

这些规则定义了语言的结构。

为什么需要定义产生式集合？

- **形式化语言结构**：产生式集合是描述语言结构的核心工具，它用一种形式化的方式定义了语言的语法。通过产生式，我们可以明确地表示语言的结构和层次。
- **指导编译器实现**：编译器的语法分析阶段需要根据产生式规则来解析源代码。产生式集合为编译器的实现提供了明确的指导。

## 4. 开始符号（Start Symbol）

开始符号是文法的入口，表示整个语言的最高层次结构。比如在C++的文法中，程序的入口可能是`Program`。

为什么需要定义开始符号？

- **明确入口**：开始符号是文法的起点，它定义了整个语言的最高层次结构。有了开始符号，我们就可以从一个统一的入口开始解析语言。
- **简化分析**：在语法分析过程中，编译器可以从开始符号开始，逐步应用产生式规则，直到完全解析源代码。

## 5. 描述文法

一般使用多个产生式来描述文法，并且第一个是开始符号对应的产生式。

### 案例1：加减数字串

对于这样一串数字：`9-5+2`，可以看作由下面的文法组成语言：

```
list -> list + digit
list -> list - digit
list -> digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

以`list`为头部的三个产生式可以等价组合为：

```
list -> list + digit | list - digit | digit
```

推导：

* 因为9是digit，所以9是list
* 因为9是list，且5是digit，所以9-5是list
* 因为9-5是list，且2是digit，所以9-5+2是list

### 案例2：函数调用中的参数列表

在C++语言中，函数调用时，()中的内容可能是空的。这时就会产生一个非常微妙的情况。下面的文法描述涵盖了这种情况（下面的epsilon代表$\epsilon$）：

```
call -> id(optparams)
optparams -> params | epsilon
params -> params, param | param
```

推导：

* $\epsilon$在2中是optparams
* f($\epsilon$)是call