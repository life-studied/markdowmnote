---
create: 2023-07-08
modified: '2024-11-17'
---

## 委托构造函数

为了合理复用构造函数，C++11提供了委托构造函数。委托者被成为委托构造函数，被委托者被称为代理构造函数。

下面是一个例子：

```C++
class X
{
public:
    X() : X(0, 0.) {}
    X(int a) : X(a, 0.) {}
    X(double b) : X(0, b) {}
    X(int a, double b) : a_(a), b_(b) {}

private:
    int a_;
    int b_;
};
```

此外有几个注意点：

* 每个构造函数可以委托另一个代理构造函数（包括代理构造函数）

* 不要递归循环委托
* 委托构造函数的初始化列表中不能再对**数据成员**和**基类**进行初始化
* 委托构造函数的执行顺序：
	* 代理构造函数的初始化列表
	* 代理构造函数主体
	* 委托构造函数主体
* 代理构造函数执行完成后，在委托构造函数主体抛出了异常，则会调用类的析构函数（因此类已经被代理构造函数构造了，只是在委托构造函数的主体中进行进一步的赋值）
	* 注意：正常构造函数执行过程中如果抛出异常，不会调用析构函数，从而会产生资源泄露等问题。