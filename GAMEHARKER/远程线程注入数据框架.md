## 远程线程注入数据框架

> 通过远程线程注入的方式，不能直接调用本程序里的函数，因此需要将被调用的函数和相应的数据写入到对方的内存中，再去调用。

步骤：

* 在对方内存分配空间
* 获取系统dll（例如kernel.dll）的地址
	* 在不同exe中一般在同一地址
* 将系统dll的地址和需要用到的参数数据写入到对方的内存中
* 将注入的函数写入到对方的内存中
* 开启一个远程线程，执行注入的函数，调用所用的dll函数

```C++
#include <Windows.h>
#include <tchar.h>
#include <iostream>
typedef unsigned int(WINAPI *f_LoadLibrary)(wchar_t *dllName);		//函数指针
HANDLE hProcess;	//远程进程的句柄
struct RemoteData	//数据框架，用于注入到对方的内存来被函数调用
{
    wchar_t dllName[0xff];
    f_LoadLibrary pLoadLiarbry;
};

void INJECT()		//被注入的函数
{
    unsigned address = 0xCCCCCCCC;
    RemoteData data;
    data.pLoadLiarbry(data.dllName);
}

void CodingRemoteData(RemoteData &rdata)		//编码数据框架（初始化结构体）
{
    HMODULE hKernel;
    hKernel = LoadLibrary(_T("kernel32.dll"));

    short lenth{};
    const wchar_t *dllName = L"";
    for (lenth = 0; dllName[lenth++];)
        ;
    rdata.pLoadLiarbry = (f_LoadLibrary)GetProcAddress(hKernel, "LoadLibraryW");

    memcpy(rdata.dllName, dllName, (lenth + 1) * 2);
}

void CreateRemoteCode(RemoteData &rdata, LPVOID &remoteAdr)	//将注入的函数做一个修正，开始注入
{
    CodingRemoteData(rdata);
    char _code[0x200];
    memcpy(_code, (const void *)INJECT, sizeof(_code));
    for (int i = 0; i < 0x100; i++)
    {
        unsigned *pcode = (unsigned *)(&_code[i]);
        if (pcode[0] == 0xCCCCCCCC)
        {
            pcode[0] = (unsigned)remoteAdr;
            break;
        }
    }
    SIZE_T lwt;
    WriteProcessMemory(hProcess, (LPVOID)remoteAdr, (LPCVOID)INJECT, 0x200, &lwt);
}

int main(int argc, char const *argv[])
{
    DWORD PID{};
    std::cin >> PID;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);	//获取进程句柄
    if (hProcess != NULL)
    {

        CloseHandle(hProcess);
    }

    RemoteData rdata;

    LPVOID adrRemote = VirtualAllocEx(hProcess, 0, 0x3000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);						//分配远程内存空间
    CreateRemoteCode(rdata, adrRemote);
    return 0;
}

```

